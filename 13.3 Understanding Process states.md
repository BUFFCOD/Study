

# Understanding Process States

- New processes are created with `fork()`/`clone()`; the scheduler places them on a run queue and gives them CPU time slices.
- A process can move between running, runnable, and waiting states many times; preemption simply moves it off a CPU and back to the run queue.

| State name            | Code | What it means                                                                                   | Notes                                                        |
|-----------------------|------|-------------------------------------------------------------------------------------------------|--------------------------------------------------------------|
| Running / Runnable    | R    | Actively on a CPU (running) or ready on the run queue (runnable).                              | Can be preempted or rescheduled at any time.                 |
| Interruptible sleep   | S    | Waiting for an event/resource; can wake on signals.                                            | Common for I/O waits.                                        |
| Uninterruptible sleep | D    | Waiting for a resource; ignores signals until the wait ends.                                   | Protects critical waits (often I/O).                         |
| Killable sleep        | K    | Like uninterruptible, but responds to fatal signals.                                           | Rare; allows `kill -9` to succeed.                           |
| Stopped / Traced      | T    | Suspended via `SIGSTOP`/`SIGTSTP` or being traced by a debugger.                               | Resume with `SIGCONT`.                                       |
| Idle                  | I    | Kernel idle threads; not doing work.                                                           | Seen on some kernels as `I`.                                 |
| Zombie                | Z    | Exited, but parent has not read exit status yet; slot remains in process table.                | `ps` shows `<defunct>`; no CPU/mem use, but holds PID slot.  |
| Exit (dead)           | X    | Being fully cleaned up/reaped after `wait()`; typically transient.                             |                                                              |

Extras to remember:
- Parent should reap children with `wait()`/`waitpid()`; if a parent dies, `init`/`systemd` will adopt and reap.
- High load with many `R` tasks can indicate CPU contention; many `D` tasks often point to I/O bottlenecks.
